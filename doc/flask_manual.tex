\documentclass[12pt]{book} % Possui capítulos, título e resumo ocupam página toda, 2-sided, inclui header com # da pág, capítulo e seção.

\usepackage{graphicx}                            % Para poder incluir gráficos.
\usepackage{natbib}                              % \citep{jon90} --> (Jones et al., 1990)
\usepackage{amssymb}                             % Para poder utilizar alguns símbolos matemáticos especiais.
\usepackage[usenames,dvipsnames]{color}          % Para ampliar a quantidade de cores utilizáveis.
\usepackage[colorlinks,citecolor=Blue,linkcolor=BrickRed]{hyperref} 
\usepackage[nottoc]{tocbibind}                   % Para incluir referências bibliográficas no sumário.
                                                 % Para colocar links nas referências, equações, figuras, etc, além de menu árvore no PDF.

%%% Formatação %%%
\usepackage[small,bf]{caption}                   % Para que legendas de figuras e tabelas fique em fonte menor e com negrito.
\usepackage{fancyhdr}                            % Para poder fazer cabeçalhos e rodapés mais bonitos.
\usepackage{mathptmx}                            % Para mudar a fonte usada na matemática para uma mais parecida com times. 
\usepackage{helvet}                              % Para que a fonte não-serifada seja Helvetica.
\usepackage{titlesec}                            % Para mudar a formatação dos títulos dos capítulos e seções.
\titleformat{\chapter}[display]
  {\normalfont\sffamily\Large}
  {\chaptertitlename\ \thechapter}{10pt}{\LARGE\bfseries}
\titleformat*{\section}{\Large\sffamily\bfseries\raggedright}
\titleformat*{\subsection}{\large\sffamily\bfseries}
\titleformat*{\subsubsection}{\normalsize\sffamily\bfseries}

\newcommand{\Tstrut}{\rule{0pt}{2.3ex}}          % = `top' strut
\newcommand{\xline}{\hline\Tstrut}               % Linha de tabela com mais espaço
\usepackage{dcolumn}                             % Para alinhar números em tabelas pela vírgula
\newcolumntype{d}[1]{D{.}{,}{#1}}                % Para alinhar números em tabelas pela vírgula
\newcommand{\nt}[1]{\multicolumn{1}{r}{#1}}      % Para colocar coisas sem vírgula na tabela
\newcommand{\ctit}[1]{\multicolumn{1}{c}{#1}}    % Para colocar títulos na tabela com dcolumn

\newcommand{\dd}{\mathrm{d}}                     % Para o 'd' de diferencial não ficar em itálico.
\newcommand{\nv}[1]{\mathrm{#1}}                 % Para abreviar o formato mathroman. 
\newcommand{\la}{\lesssim}                       % Abreviação de menor que aprox.
\usepackage{mathtools}                           % To use dcases environment in equations.

\newenvironment{alltt}{\ttfamily}{\par}
\usepackage{moreverb}
\usepackage{caption}


% Define as bordas do documento
\usepackage[a4paper, top=2.5cm, bottom=3.5cm, inner=3.0cm, outer=3.0cm]{geometry}

% Redefinindo estilo da página de início de capítulo
\fancypagestyle{plain}{
\fancyhf{}                                           % Limpa definições anteriores.
\fancyfootoffset{0cm}                                % Estica o rodapé pra fora das margens.
\fancyfoot[LE,RO]{\footnotesize \thepage}            % Número da página nas quinas e em negrito.
\renewcommand{\headrulewidth}{0pt}                   % Tira linha do cabeçalho.
\renewcommand{\footrulewidth}{0pt}}                  % Tira linha do rodapé.
\pagestyle{fancy}                                    % Define estilo das outras páginas.
\fancyhf{}                                           % Limpa definições anteriores.
\fancyhead[LE]{{\sffamily \scriptsize \leftmark}}    % Capítulo na esquerda.
\fancyhead[RO]{{\sffamily \scriptsize \rightmark}}   % Seção na direita.
\fancyfootoffset{0cm}                                % Estica o rodapé pra fora das margens. 
\fancyfoot[LE,RO]{\footnotesize \thepage}            % Número da página nas quinas e em negrito.

\let\origdoublepage\cleardoublepage                  % Para deixar em branco páginas sem conteúdo 
\newcommand{\clearemptydoublepage}{%
  \clearpage
  {\pagestyle{empty}\origdoublepage}%
}
\let\cleardoublepage\clearemptydoublepage            % Fim do deixar em branco páginas sem conteúdo

% Para capa fancy
\newcommand{\lyxline}[1][1pt]{
  \par\noindent
    \rule[.5ex]{\linewidth}{#1}\par}

%%% Começo do documento %%%
\begin{document}

%--------------------Página de rosto------------------------%
\begin{titlepage}                                                 
\begin{center}
%\vspace{12cm}
{\Huge \sffamily \bfseries FLASK:\vspace{0.5cm}\linebreak 
Full-sky Lognormal Astro-fields Simulation Kit}\\
\vspace{1cm}
\includegraphics[width=0.6\textwidth]{flask_logo.eps}\\
\vspace{1cm}
{\LARGE \sffamily Usage and installation manual}
\end{center}
\vspace{1.5cm}
\begin{flushright}
\begin{minipage}[c][1\totalheight][t]{9 cm}
\lyxline{\normalsize}
\vspace{0.2cm}
\textbf{Written by:} Henrique S. Xavier\\
\textbf{Contact:} {\tt hsxavier@if.usp.br}\\
\linebreak
University College London, UK\\
Universidade de S\~{a}o Paulo, Brazil
\vspace{0.2cm}
\lyxline{\normalsize}
\end{minipage}
\par\end{flushright}
\vspace{1cm}
\begin{center}
{\normalsize\today}
\end{center}
\end{titlepage}
%-----------------------------------------------------------%
\newpage
\thispagestyle{empty}

% Índice
\tableofcontents

% Começo de verdade da monografia 

\chapter{Disclaimer}
\label{sec:disclaimer}

   {\sc flask} is free software, written by Henrique S. Xavier; 
   you can redistribute it and/or modify it under the terms of the GNU 
   General Public License as published by the Free Software Foundation; 
   either version 2 of the License, or (at your option) any later version.

   {\sc flask} is distributed in the hope that it will be useful,
   but without any warranty; without even the implied warranty of
   merchantability or fitness for a particular purpose. See the
   GNU General Public License for more details. You should have received 
   a copy of the GNU General Public License along with {\sc flask}; if not, 
   write to the Free Software Foundation, Inc., 59 Temple Place, Suite 330, 
   Boston, MA  02111-1307  USA.

   Thank you for using this software. Please report any bugs to {\tt hsxavier@if.usp.br} and
   acknowledge {\sc flask} by citing the publication \citet{Xavier16mn}.
   

\chapter{Installation}
\label{sec:installation}

\section{Requirements}
\label{sec:requirements}

{\sc Flask} is a code written in {\sc C++} that uses {\sc OpenMP} for parallelization; 
{\sc healpix}\footnote{{\tt \href{http://healpix.jpl.nasa.gov}{http://healpix.jpl.nasa.gov}}} for 
mapping the sky and performing harmonic transforms; the Gnu Scientific 
Library\footnote{{\tt \href{http://www.gnu.org/software/gsl}{http://www.gnu.org/software/gsl}}} 
({\sc GSL}) to generate pseudo-random numbers, to perform Cholesky decompositions and other tasks; and the 
{\sc cfitsio}\footnote{{\tt \href{http://heasarc.gsfc.nasa.gov/fitsio}{http://heasarc.gsfc.nasa.gov/fitsio}}} 
library to input and output FITS files. Apart from {\sc healpix}, all the remaining dependencies should 
be available on Linux and Mac repositories. {\sc Healpix} however should be easy to install (just 
follow their instructions); {\sc Flask} requires version 3.11 or later of the C++ {\sc healpix} 
implementation due to the {\tt T\_Healpix\_Base<I>::boundaries} function, introduced in version 3.11. 
{\sc Flask} has been fully operational under {\sc healpix} versions 3.11, 3.20, 3.31, 3.50 and
(since March 8th, 2020) 3.60.

So far {\sc Flask} has been tested only on Linux distributions -- Scientific Linux 5.6 and Ubuntu 14.04 -- 
and compiled with {\tt g++} (GCC) versions 4.4.7, 4.8.1, 4.8.4 and 7.4.0.   
Besides the main code and other routines in {\sc C++}, {\sc flask} also includes auxiliary {\sc python} 
and {\sc shell} scripts. These were tested in {\sc bash} shell and {\sc python} versions 2.7.3 and 2.7.6.
The {\sc python} scripts require a few packages like {\sc numpy}, {\sc scipy} and {\sc healpy} 
(which can be installed by following {\sc healpix} instructions). Check the scripts for further dependencies.  
Transition to {\sc python} 3 is under way.

\section{Compiling}
\label{sec:compiling}

Before compiling, you will have to modify the {\tt Makefile} in the {\tt src} sub-directory of {\sc flask}. 
The following lines must be changed according to the location of the {\sc healpix} installation directory:

\vspace{0.5cm}

\noindent
{\tt HEALDIR = <path to Healpix directory>}

\noindent
{\tt CXXHEAL = -I<path to Healpix header files>}

\noindent
{\tt LDHEAL  = -L<path to Healpix library files>} 
\vspace{0.5cm}

\noindent
In case other libraries such as {\sc cfitsio}, {\sc gsl} are installed in non-standard locations, 
you might need to specify their locations with similar compiler flags (i.e. {\tt CXXFITS}, {\tt LDFITS}, 
{\tt CXXGSL} and {\tt LDGSL}, commented in the {\tt Makefile}). The default compiler in the 
{\tt Makefile} is {\tt g++}, you might need to change the keyword {\tt COMP} as well if using a 
different compiler.

After changing the {\tt Makefile}, run the command {\tt make} in the {\tt src} directory. The 
executables will be built in {\sc flask} {\tt bin} sub-directory. You may add this sub-directory to 
your {\sc path} environment variable in order to be able to run {\sc flask} anywhere; otherwise, 
you will require to run it from there or to provide the full path as usual. 

\subsubsection{Note on Healpix versions}

{\sc Healpix} is constantly updated, and some updates may remove and substitute functions,
change location of files or library dependencies, all of which may prevent {\sc flask} from
compiling. The {\sc flask} code and the {\tt Makefile} in particular are updated from time to time
to allow {\sc flask} to run with the latest {\sc healpix} version as well as the previous versions
(the {\sc Makefile} finds out the {\sc healpix} version and tries to set the requirements accordingly).
If you run into trouble compiling, check if your {\sc healpix} version is currently supported by
{\sc flask} (these are listed in Sec. \ref{sec:requirements}).


\chapter{Usage}
\label{sec:usage}

\section{Using {\sc flask}}
\label{sec:flask}

\subsection{Quick start}
\label{sec:quick-start}

To get a feeling of {\sc flask} and to test if things are working fine, go to the {\sc flask} 
directory and run the command:

\vspace{0.5cm}
\noindent
{\tt ./bin/flask example.config}
\vspace{0.5cm}

\noindent
This should result in a clean run (no errors or warnings) and should make {\sc flask} 
use typical data stored in the {\tt data} sub-directory to create 
the most relevant outputs into the {\tt example} sub-directory (which should be empty), 
including maps and catalogs simulations. Since writing files to the hard-disk is a slow process, 
this run will take much longer than an usual {\sc flask} run that only outputs one or two files 
(text files, in particular, take a long time to write). 
To figure out what the output files are, check the file {\tt example.config} and Sec. 
\ref{sec:keywords}.
 
\subsection{Basic operation}
\label{sec:operation}

{\sc Flask} is executed through the command line, and it always requires a configuration file 
(e.g. {\tt example.config} in the {\sc flask} directory):

\vspace{0.5cm}
\noindent
{\tt flask <config file>}
\vspace{0.5cm}

Any keyword in the configuration file can be altered from the command line by specifying its 
name {\tt<keyword\_i>} and value {\tt<value\_i>} after passing the configuration file to {\sc flask}: 

\vspace{0.5cm}
\noindent
{\tt flask <config file> <keyword\_1>: <value\_1> <keyword\_2>: <value\_2>...}
\vspace{0.5cm}

\noindent
For example,

\vspace{0.5cm}
\noindent
{\tt flask example.config RNDSEED: 334 MAP\_OUT: ./map-002.dat}
\vspace{0.5cm}

{\sc Flask} outputs to the screen a comprehensive description of what it is doing. In case you want to 
store this information for later, you might want to redirect the output to a file, e.g.: 

\vspace{0.5cm}
\noindent
{\tt flask example.config RNDSEED: 334 MAP\_OUT: ./map-002.dat > r334.log}

\noindent
or

\noindent
{\tt flask example.config RNDSEED: 334 MAP\_OUT: ./map-002.dat | tee r334.log}
\vspace{0.5cm}


\subsection{Tips and things to keep an eye on}
\label{sec:tips}

{\sc Flask}'s screen output contains a lot of information that may help 
to reproduce previous runs and output files, understand the simulation process, 
and identify mistakes and bugs. For instance, it contains the {\sc flask}'s version 
(git commit) and all parameters used. All file outputs are announced with a {\tt >>} sign 
and all warnings and errors are announced with {\tt !!} signs. At the end of the 
screen output one can see the total number of warnings generated during the run. 
{\sc Flask} was designed to produce warnings for all possible mistakes we could think of, so 
to correctly use {\sc flask}, make sure that the total number of warnings is always zero 
or (if it is really necessary) that you understand and can afford specific warnings.

If a regularization of the covariance matrix was requested, check the screen output 
since it informs you the maximum fractional change applied to them. Also, in Gaussian 
realisations and in some other situations you may end up with negative galaxy counts, 
something that is also informed by the screen output. These things can distort your 
results (and they do not produce warnings), so pay attention to them. 

{\sc Flask} can output practically all intermediary data it produces. If you get some 
weird result, you can check the data used in the previous calculation steps to 
find out where the problem is. 
   

\subsection{Inner workings}
\label{sec:workings}

The internal process followed by {\sc flask} is described in \citet{Xavier16mn}. 
Fig. \ref{fig:flow-chart} shows a flow chart that roughly described the 
operations sequences. Some processes are only performed when simulating lognormal 
fields (Gaussian simulations may skip a few of them). Other processes like 
creating triangular matrices used for generating correlated random variables and 
performing a density line-of-sight (LoS) integration to get the convergence are 
optional (they are executed according to the specifications in the configuration file).
Here we describe a few processes not discussed in \citet{Xavier16mn}. The noise 
creation processes are presented in the description of the keywords for generating 
outputs (maps, catalogues, etc.) that include these noises (check Sec. \ref{sec:keywords}).  

\begin{figure}
  \includegraphics[width=1\textwidth]{flask_flow_chart.eps}
  \caption{{\sc Flask} basic flow chart. It starts on the top left corner.}
\label{fig:flow-chart}  
\end{figure}

\subsubsection{Computing $C_\ell$s from $a_{\ell m}$s}

When recovering an angular power spectra $C_\ell^{ij}$ from realized multipoles $a_{\ell m}^{i}$, 
the following computation is performed:

\begin{equation}
C_\ell^{ij} = \frac{1}{\ell+1}\sum_{m=0}^\ell a_{\ell m}^{i}a_{\ell m}^{j*}.
\label{eq:recov-cl}
\end{equation}
We do not sum over negative $m$s because the fields are real and therefore 
$(-1)^m a_{\ell -m}^{i} = a_{\ell m}^{i*}$.

\subsection{Selection function}
\label{sec:selection}

\subsubsection{Galaxy fields}

When sampling a density field with discrete tracers (e.g. galaxies), the expected number 
of tracers $\langle N_t(i,j) \rangle$ of type $t$ in each pixel $j$ of the redshift shell $i$ 
is given by:

\begin{equation}
\langle N_t(i,j) \rangle = \bar{n}_t(i,j)[1+\delta_t(i,j)]\Delta\Omega,
\label{eq:tracer-number}
\end{equation}
where $\Delta\Omega$ is the pixel angular area in $\mathrm{arcmin}^2$, $\bar{n}_t(i,j)$ 
is the expected number of tracers $t$ per $\mathrm{arcmin}^2$ that would be observed 
in pixel $j$ and redshift shell $i$ in a completely homogeneous universe, 
$\delta_t(i,j)$ is the tracer $t$ density contrast field generated according 
to the input power spectra. The actual number of tracers generated in each cell can be sampled 
from a Poisson distribution with average number given by $\langle N_t(i,j) \rangle$ if the keyword 
{\tt POISSON} is set to {\tt 1}, or from a Gaussian distribution with mean given by 
$\langle N_t(i,j) \rangle$ and standard deviation $\sigma_{\mathrm{G}} = \sqrt{\bar{n}_t(i,j)\Delta\Omega}$ 
if {\tt POISSON} is set to {\tt 2} (note that in this case the number of tracers can be non-integer and 
negative).

The way $\bar{n}_t(i,j)$ behaves depends on the {\tt SELEC\_TYPE} keyword (see Section \ref{sec:keywords}). 
If {\tt SELEC\_TYPE: 0}, then $\bar{n}_t(i,j)$ is given by:

\begin{equation}
\bar{n}_t(i,j) = a_{\mathrm{s}} \times S(j) \times W_t(i,j).  
\label{eq:selection-function} 
\end{equation}
Here, $a_{\mathrm{s}}$ is a scaling factor specified by the {\tt SELEC\_SCALE} keyword, 
$S(j)$ is an angular mask specified by {\tt STARMASK} and $W_t(i,j)$ depends on the 
{\tt SELEC\_SEPARABLE} keyword (see Section \ref{sec:keywords}). For 
{\tt SELEC\_SEPARABLE: 0}, $W_t(i,j)$ is given by a set of {\sc healpix} maps (one for 
each tracer $t$ and redshift $i$) with prefixes determined by {\tt SELEC\_PREFIX}. For 
{\tt SELEC\_SEPARABLE: 1}, we have:

\begin{equation}
W_t(i,j) = A(j)\int_{z^{\rm{min}}_i}^{z^{\rm{max}}_i} f_t(z) \rm{d}z,  
\label{eq:separable-selection-function} 
\end{equation}
where $f_t(z)$ is a radial selection function for the tracer $t$ 
given by files with prefix {\tt SELEC\_Z\_PREFIX} [the value of $f_t(z)$ 
is linearly interpolated from the tabulated values]; $z^{\rm{min}}_i$ and 
$z^{\rm{max}}_i$ are the minimum and maximum redshifts for the redshift shell $i$, 
specified in the file given by the {\tt FIELDS\_INFO} keyword (see also Sec. 
\ref{sec:fields-info}); and $A(j)$ is an 
angular selection function given by a single {\sc healpix} map, passed to {\tt SELEC\_PREFIX}. 
Note that the units of $a_{\mathrm{s}}$, $S(j)$, $W_t(i,j)$, $f_t(z)$ and $A(j)$ are arbitrary; 
however, they must be such that the final units of $\bar{n}_t(i,j)$ are number of tracers 
per $\mathrm{arcmin}^2$. In most cases, people choose $f_t(z)$ to carry 
all the units [i.e. $f_t(z)$ is given as number of galaxies per $\mathrm{arcmin}^2$, 
per unit redshift] and leave the remaining terms as dimensionless quantities.

It is also possible to set {\tt SELEC\_SEPARABLE: 2}, a variant of the separable case {\tt 1} in 
which different density tracers have different angular selection functions. In mathematical 
terms, with this option $A(j)$ in Eq. \ref{eq:separable-selection-function} is replaced by 
$A_t(j)$, and each tracer must have a Healpix map representing $A_t(j)$ with prefix given by 
{\tt SELEC\_PREFIX}. This allows, for instance, the correlated simulation of multiple surveys.

If {\tt SELEC\_TYPE: 1}, $\bar{n}_t(i,j)$ is given by:

\begin{equation}
\bar{n}_t(i,j) = a_{\mathrm{s}} \times S(j) \times W_t(i,j) \times \rho_t(i),
\label{eq:fraction-selection-function} 
\end{equation}
where $a_{\mathrm{s}} \times S(j) \times W_t(i,j)$ is the fraction of tracers $t$ 
that get observed and $\rho_t(i)$ is the true underlying density. This option is 
currently not implemented. The user can add 2 to both {\tt SELEC\_TYPE} options 
to set $S(j)$ and $A(j)$ to 1 and use their information only as bookkeeping numbers 
in the catalogue output ({\tt CATALOG\_OUT}). 

Finally, note that the user may describe completely masked out pixels in $S(j)$ and $A(j)$  
-- and in $W_t(i,j)$ if {\tt SELEC\_SEPARABLE: 0}, i.e. in any {\sc healpix} map describing the 
selection function -- by zero or by any negative number.

\subsubsection{Lensing fields}

In most cases, {\sc flask} does not use selection functions assigned to lensing fields 
(the user does not have to supply and {\sc flask} will not read them) since it 
is only used to go from galaxy density contrast to galaxy counts. The exception would be 
if the simulation only includes lensing fields and at least one of the outputs controlled by the 
following keywords is requested: {\tt MAPWER\_OUT}, {\tt MAPWERFITS\_PREFIX}, 
{\tt ELLIP\_MAP\_OUT} and {\tt ELLIPFITS\_PREFIX}. Since these outputs refer to partial 
sky, noisy data and the selection function affects them by masking regions and modulating 
shape noise inside pixels through source density, {\sc flask} assumes that a selection 
function was provided for the lensing fields and attempts to read it and use it. 
For ellipticity maps, the selection function is used both to mask out regions where no 
galaxies were observed and to specify the shape noise at each redshift slice and pixel
(check the {\tt ELLIP\_SIGMA} keyword in Sec. \ref{sec:keywords} for more details).
For the convergence fields, the only effect of the selection function in the current 
implementation is to mask out specific regions (i.e. no noise is added to the output maps). 

If there are galaxy fields in the simulation, {\sc flask} will apply their selection 
functions to the lensing fields. In this case and in the current implementation, 
the {\tt MAPWER\_OUT} and {\tt MAPWERFITS\_PREFIX} 
outputs will produce masked convergence maps only if {\tt SELEC\_SEPARABLE: 1} 
(otherwise, {\sc flask} will return unmasked convergence maps). If requested through 
{\tt ELLIP\_MAP\_OUT} or {\tt ELLIPFITS\_PREFIX}, {\sc flask} will create ellipticity 
maps for each galaxy field provided, using their selection functions to calculate the 
appropriate shape noise levels. 
 
  
\subsection{Configuration file keywords}
\label{sec:keywords}

{\sc Flask} is built in a way that all the existing keywords in the code must be present in the 
configuration file otherwise a warning message is issued; this is to avoid setting keywords to 
values unknown by the user and to disclose to the user all available options in the code. 
{\sc Flask} will also complain if keywords that do not exist in the code are present in the 
configuration file or are passed through the command line; keywords are identified by a colon (:) 
after it, so this should not be used for other purposes inside configuration files. Although 
the hash (\#) is used to identify comments, this is only for aesthetic reasons and does not have 
any effect on the parsing of the configuration file ({\tt \# DENS2KAPPA:} is still identified as 
the {\tt DENS2KAPPA} keyword). More information about this can be found in the {\tt example.config} 
file. 
NOTE: in the current implementation, strings passed to the keywords cannot be longer than 109 
characters. Longer strings may cause a segmentation fault when reading the configuration file. 

{\sc Flask} goes through a series of sequential computations that transforms the simulated data somehow; 
after each step, the code can output the current status of the data. These possible outputs are 
presented in the {\tt example.config} file in the exact order they are produced. Thus, one can 
have an idea of the simulation process by reading the output options in that file. All outputs 
can be turned off by assigning {\tt 0} to the respective keyword.

We now provide a description of every keyword available in the code (a brief description of 
each one is also provided in {\tt example.config}):

\begin{itemize}

\item {\tt DIST:} This takes as value one string that can be either {\tt GAUSSIAN}, 
  {\tt LOGNORMAL} or {\tt HOMOGENEOUS}, specifying what kind of distribution all 
  the simulated random fields will follow. The {\tt HOMOGENEOUS} in fact ignores 
  all input power spectra $C(\ell)$s as if they were all zero and creates homogeneous 
  field maps. Density fields can be later Poisson (or Gaussian) sampled according to the selection 
  function, so the {\tt HOMOGENEOUS} choice is useful to create the random catalogues 
  used in \citet{LandySzalay93x}, for instance. Weak lensing shear produced under this 
  choice is currently zero, and ellipticities are completely random according to 
  {\tt ELLIP\_SIGMA}. For simulating Gaussian and lognormal correlated fields 
  simultaneously, one should use the {\tt LOGNORMAL} choice and adjust the input 
  information so to approximate the desired fields to a Gaussian distribution. Note that 
  the {\tt GAUSSIAN} option might lead to unphysical field values in some cases (e.g. 
  negative densities), which might cause problems in some simulations steps (like sampling 
  galaxies).

\item {\tt RNDSEED:} This is a single integer number, the seed for the pseudo-random 
  number generator. In fact, the seed is transformed into $N_{\nv{proc}}$ seeds, where 
  $N_{\nv{proc}}$ is the number of processors available for parallel computing with 
  {\sc OpenMP}. This transformation is such that every seed provided to {\tt RNDSEED} 
  will result in different and exclusive set of $N_{\nv{proc}}$ ``sub-seeds'' so that different seeds truly 
  result in independent realisations. Note that a given seed passed to {\tt RNDSEED} will 
  only result in the same realisation as long as $N_{\nv{proc}}$ remains the same.

\item {\tt POISSON:} This can be {\tt 1}, {\tt 2} or {\tt 0}, and specifies if the galaxy density 
  fields should be Poisson sampled, Gaussian sampled or not sampled at all, respectively. 
  If not sampled (useful for debugging reasons), the values attributed to the {\sc healpix} count maps 
  are the expected number of galaxies (a non-integer number); if Gaussian sampled, these values 
  will be non-integer and they can be negative as well. These maps can then be output 
  through the {\tt MAPWER\_OUT} and {\tt MAPWERFITS\_PREFIX} keywords. Generating a galaxy catalogue 
  from maps with {\tt POISSON: 0} or {\tt 2} would not make much sense and is likely to cause the 
  code to crash. For more information on the parameters used for the sampling, check Sec. 
  \ref{sec:selection}.

\item {\tt OMEGA\_m:} This takes a real number that represents the total matter (dark matter 
  plus baryons) density parameter. It is only used if the user sets: (1) {\tt DENS2KAPPA: 1}; 
  (2) {\tt SELEC\_TYPE: 1} or {\tt SELEC\_TYPE: 3}; or includes {\tt r} in the 
  list of catalogue columns {\tt CATALOG\_COLS} and generates a catalogue.

\item {\tt OMEGA\_L:} This takes a real number that represents the dark energy density parameter. 
  It is only used if the user sets:  (1) {\tt DENS2KAPPA: 1}; 
  (2) {\tt SELEC\_TYPE: 1} or {\tt SELEC\_TYPE: 3}; or includes {\tt r} in the 
  list of catalogue columns {\tt CATALOG\_COLS} and generates a catalogue.

\item {\tt W\_de:} This takes a real number that represents the $w_0$ parameter of a constant dark energy 
  equation of state. It is only used if the user sets:  (1) {\tt DENS2KAPPA: 1}; 
  (2) {\tt SELEC\_TYPE: 1} or {\tt SELEC\_TYPE: 3}; or includes {\tt r} in the 
  list of catalogue columns {\tt CATALOG\_COLS} and generates a catalogue.
  Currently this is the only kind of dark energy model implemented in the code. 

\item {\tt ELLIP\_SIGMA:} This takes a real number that represents the standard deviation of the zero mean 
  Gaussian distribution from which each component of a galaxy's intrinsic ellipticity 
  $\epsilon_{\nv{s}}=\epsilon_{\nv{s},1}+i\epsilon_{\nv{s},2}$ is randomly drawn. If {\tt ELLIP\_SIGMA} is 
  set to zero or less, all galaxies are considered circular ($\epsilon_{\nv{s}}=0$).

  The final ellipticity $\epsilon=\epsilon_1+i\epsilon_2$ of a galaxy in the catalogue (produced by the 
  {\tt CATALOG\_OUT} keyword) is:
  
  \begin{equation}
    \epsilon = 
    \begin{dcases}
      \frac{\epsilon_{\nv{s}}+g}{1+g^{*}\epsilon_{\nv{s}}}, & |g|\leq 1; \\
      \frac{1+g\epsilon_{\nv{s}}^{*}}{\epsilon_{\nv{s}}^{*}+g^{*}}, & |g|>1;\\
    \end{dcases}
    \label{eq:ellipticity}
  \end{equation}
  where $g\equiv \gamma/(1-\kappa)$ is the reduced shear, $\gamma=\gamma_1+i\gamma_2$ is the shear, $\kappa$ is the 
  convergence \citep[we follow ][eq. 4.12]{Bartelmann01mn}. 
  For the ellipticity maps of redshift slices -- produced by the keywords {\tt ELLIP\_MAP\_OUT} and 
  {\tt ELLIPFITS\_PREFIX} --, {\sc flask} adopts the weak lensing approximation, 
  $\epsilon(i) \simeq g(i) + \epsilon_{\nv{s}}(i)$ for the galaxy $i$. Since the ellipticity value 
  in each pixel would be the average over the ellipticities of the galaxies in that pixel 
  and the noise is assumed Gaussian, the final ellipticity in pixel $j$ is:

  \begin{equation}
    \epsilon(j) = \frac{1}{N_{\nv{gal}}(j)}\sum_i^{N_{\nv{gal}}(j)} \left[ g(i)+\epsilon_{\nv{s}}(i) \right] 
    = g(j) + \frac{\epsilon_{\nv{s}}}{\sqrt{N_{\nv{gal}}(j)}},
    \label{eq:ellip-map-noise}
  \end{equation}
  where $\epsilon_{\nv{s}}$ is drawn using the {\tt ELLIP\_SIGMA} dispersion, $N_{\nv{gal}}(j)$ is 
  the number of galaxies in pixel $j$ of that redshift slice and $g(j)$ is the value for the 
  reduced shear in pixel $j$ of that redshift slice. $N_{\nv{gal}}(j)$ is either given by the galaxy 
  count maps (after Poisson sampling) -- if produced in the same simulation run -- or by the expected 
  number of galaxies, according to the supplied selection function (see more about this in the 
  description of the {\tt ELLIP\_MAP\_OUT} and {\tt ELLIPFITS\_PREFIX} keywords). 
  
  Finally, note that the intrinsic ellipticities generated for the catalogue output and for the 
  {\sc healpix} maps output are, in the current implementation, different and independent processes 
  (the first one follows Eq. \ref{eq:ellipticity} for each galaxy while the second one follows Eq. 
  \ref{eq:ellip-map-noise} for each pixel). 
  This means that if you create ellipticity maps from the catalogue you will not get the exact output 
  given by {\tt ELLIP\_MAP\_OUT} or {\tt ELLIPFITS\_PREFIX}, unless you set {\tt ELLIP\_SIGMA}$\leq 0$ 
  (although they will be statistically equivalent in the weak lensing regime).
  
\item {\tt GALDENSITY:} This takes a real number representing the 3D comoving galaxy number 
  density in $(h^{-1}\nv{Mpc})^{-3}$. It is only used if {\tt SELEC\_TYPE: 1} or {\tt SELEC\_TYPE: 3}. 

\item {\tt FIELDS\_INFO:} This takes a string representing the path to the fields information file 
  described in Sec. \ref{sec:fields-info}.

\item {\tt CHOL\_IN\_PREFIX:} This takes the character {\tt 0} or a string representing the path, including 
  a file prefix, to the files written by the keyword {\tt CHOLESKY\_PREFIX} in a previous {\sc flask} run. If set to 
  {\tt 0}, the code: takes as input the power spectra $C_{\nv{in}}(\ell)$s specified by {\tt CL\_PREFIX}; 
  process it to obtain the associated Gaussian power spectra $C_{\nv{g}}(\ell)$s [if {\tt DIST: LOGNORMAL}, 
  otherwise $C_{\nv{g}}(\ell)=C_{\nv{in}}(\ell)$]; build independent covariance matrices for each $\ell$; 
  regularise the matrices if necessary and requested; and perform a Cholesky decomposition to obtain 
  triangular matrices -- which can be written to files by the {\tt CHOLESKY\_PREFIX} keyword -- used 
  to generate correlated Gaussian variables. If {\tt CHOL\_IN\_PREFIX} is not set to {\tt 0}, {\sc flask} 
  therefore skips all the processing above and loads its final product -- the triangular matrices, previously
  computed -- into the memory.

\item {\tt CL\_PREFIX:} This takes a string that represents the path (including a prefix) to all 
  power spectra $C^{ij}(\ell)$ required to specify the statistical properties of the set of fields 
  listed in the fields information file specified by {\tt FIELDS\_INFO}. Each $C^{ij}(\ell)$ must 
  be in a separate file with two columns [$\ell$ and $C^{ij}(\ell)$] and must be named with the 
  pattern $[prefix]${\tt f}$[f_i]${\tt z}$[z_i]${\tt f}$[f_j]${\tt z}$[z_j]${\tt .dat}. This string is only used 
  if {\tt CHOL\_IN\_PREFIX} is set to zero.

  It is also possible to pass a single {\tt .dat} file to {\tt CL\_PREFIX} containing all required 
  $C^{ij}(\ell)$s. In this case, the file must have the multipole $\ell$ in the first column and 
  the $C^{ij}(\ell)$s in the following columns, and the header must be: 
  ``{\tt \# l Cl-f}$[f_i]${\tt z}$[z_i]${\tt f}$[f_j]${\tt z}$[z_j]$ 
  {\tt Cl-f}$[f_k]${\tt z}$[z_k]${\tt f}$[f_n]${\tt z}$[z_n]$ {\tt  ~Cl-}...''. The ``{\tt Cl-}'' 
  in this header's example can actually be any string (the important part is the 
  $[f_i]${\tt z}$[z_i]${\tt f}$[f_j]${\tt z}$[z_j]$ pattern). The power spectra can be 
  arranjed in any order. If the string passed to {\tt CL\_PREFIX} ends in {\tt .dat}, {\sc Flask} 
  will assume the file is such a table. Otherwise, it will assume it is a prefix for individual 
  $C^{ij}(\ell)$ files.

\item {\tt ALLOW\_MISS\_CL:} This can be {\tt 0} or {\tt 1}. If {\tt 0}, {\sc flask} will abort 
  if any required $C^{ij}(\ell)$ is not found. If {\tt 1}, the code will assume that the missing 
  $C^{ij}(\ell)$s are zero. This works for cross power spectra but will cause the program to abort 
  if auto power spectra are missing.

\item {\tt SCALE\_CLS:} If different from 1.0, all input $C^{ij}(\ell)s$ are multiplied by 
  this factor. When simulating just a single tracer, this can be used as a constant bias term 
  $b^2$. The {\tt SMOOTH\_CL\_PREFIX} output includes this re-scaling.

\item {\tt WINFUNC\_SIGMA:} In case you want to simulate fields that have been convolved 
  (smoothed) in each redshift slice with a 2D Gaussian, you can adjust the Gaussian's standard 
  deviation here (this takes a real number, given in arcmin). The power spectra will be adjusted accordingly. 
  To skip applying this smoothing, set this value to something less than zero.

\item {\tt APPLY\_PIXWIN:} To compute the value of a pixel from the map's harmonic coefficients, 
  {\sc healpix} sums the multipoles weighted by their coefficients (i.e. performs an inverse 
  harmonic transformation) and computes the result at the angular coordinates of the pixel's 
  centre (the pixel value is not the field's average inside the pixel). In case you want the pixel 
  value to be the field's average inside the pixel (which is what people want in most cases), 
  you must apply the {\sc healpix} window function 
  to the input power spectra; this is done by setting {\tt APPLY\_PIXWIN} to {\tt 1}. To skip 
  this multiplication, set {\tt APPLY\_PIXWIN: 0}.

\item {\tt SUPPRESS\_L:} This takes a real number that represents the scale $\ell_{\nv{sup}}$ 
  at which the input power spectra $C_{\nv{in}}^{ij}(\ell)$ will be exponentially suppressed 
  with index $n$ given by {\tt SUP\_INDEX}. The suppressed power spectra $C_{\nv{sup}}^{ij}(\ell)$, 
  used for all subsequent computations and simulations, will be: 
  \begin{equation}
    C_{\nv{sup}}^{ij}(\ell) = C_{\nv{in}}^{ij}(\ell) \exp \left[ - \left(\frac{\ell}{\ell_{\nv{sup}}}\right)^n\right]
    \label{eq:exp-suppress}
  \end{equation}
  To avoid applying this suppression, set either {\tt SUPPRESS\_L} or {\tt SUP\_INDEX} (or both) 
  to something less than zero.

\item {\tt SUP\_INDEX:} This takes a real number that represents the index $n$ in Eq. 
  \ref{eq:exp-suppress} (see {\tt SUPPRESS\_L} description). You can avoid the use 
  of such suppression by setting this value to a negative number.

\item {\tt SELEC\_SEPARABLE:} This specifies if the galaxy selection function is separable between 
  radial and angular parts ({\tt 1} or {\tt 2}) or not ({\tt 0}). If separable: the selection function value is 
  the multiplication of the two; if {\tt SELEC\_SEPARABLE:} {\tt 1}, the keyword {\tt SELEC\_PREFIX} 
  will take a single FITS filename representing the angular selection function 
  as a {\sc healpix} map that will be used for all galaxy fields and all redshift slices; 
  if {\tt SELEC\_SEPARABLE:} {\tt 2}, each galaxy field must have its own angular selection function 
  represented by a {\sc healpix} map, with name given by the prefix specified by {\tt SELEC\_PREFIX} followed 
  by {\tt f}$[f_i]${\tt.fits}, where $[f_i]$ are numbers ``naming'' the galaxy fields. In either of these two cases, the 
  keyword {\tt SELEC\_Z\_PREFIX} will take a prefix leading to one radial selection function for each 
  galaxy field. 

  If not separable, the keyword {\tt SELEC\_PREFIX} will take a path with a prefix that 
  should lead to one {\sc healpix} map in FITS format for each galaxy field and redshift slice, 
  representing the entire selection function (these files must be named by the prefix followed by 
  {\tt f}$[f_i]${\tt z}$[z_j]${\tt .fits}, where $[f_i]$ and $[z_j]$ are the numbers ``naming'' 
  the entries in the fields information file -- see Sec. \ref{sec:fields-info}). 
  In this case, {\tt SELEC\_Z\_PREFIX} is ignored.

\item {\tt SELEC\_PREFIX:} This takes a string that represents either a path plus a prefix for 
  a bunch of {\sc healpix} maps in FITS format representing the galaxies selection functions 
  or the filename of a single {\sc healpix} map, representing the angular 
  part of the selection function (see {\tt SELEC\_SEPARABLE} keyword). It can also be set to 
  {\tt 0}; in this case, the code works as if the selection function (or the angular selection 
  if {\tt SELEC\_SEPARABLE:} {\tt 1} or {\tt 2}) was equal to one in every pixel. For separable selection functions, 
  this corresponds to a full-sky simulation; for non-separable selection function, this is just weird. 
  In the current implementation, the selection functions must have the same $N_{\nv{side}}$ as the one 
  passed to the {\tt NSIDE} keyword.

\item {\tt SELEC\_Z\_PREFIX:} This takes a string representing the path plus a prefix for 
  two-column (redshift and radial selection function) text files, one for each galaxy field. 
  This is ignored if {\tt SELEC\_SEPARABLE: 0}. The files can have headers if they start with {\tt \#}, 
  and they have to be named according to the prefix, followed by {\tt f}$[f_i]${\tt .dat}, where 
  $[f_i]$ is the field number ``naming'' the field in the fields information file (see Sec. 
  \ref{sec:fields-info}). For proper units, see Sec. \ref{sec:selection}. Radial selection functions 
  with negative values in the redshift range being simulated might cause unexpected behaviour in the code.

 \item {\tt SELEC\_SCALE:} This takes a real number that will serve as a re-scaling of the selection 
   function (the selection function will be multiplied by this value). To use the exact values in the 
   files specified by {\tt SELEC\_PREFIX} and {\tt SELEC\_Z\_PREFIX}, set {\tt SELEC\_SCALE: 1.0}. 
   Using negative values here might cause unexpected behaviour in the code.  

\item {\tt SELEC\_TYPE:} There are two types of selection functions: one ({\tt SELEC\_TYPE: 0}) 
  specifies either the expected number of observed galaxies per unit redshift, per square arcmin 
  ({\tt SELEC\_SEPARABLE:} {\tt 1} or {\tt 2}) or the expected number of observed galaxies per square arcmin for each 
  redshift slice ({\tt SELEC\_SEPARABLE: 0}). The other ({\tt SELEC\_TYPE: 1}) specifies the 
  fraction of existing galaxies that are actually observed at each angular 
  position and redshift. In the latter case, the total existing galaxies 
  is computed from the galaxy density given at {\tt GALDENSITY} and the comoving volume calculated 
  according to the pixel size (determined by {\tt NSIDE}), the redshift slice width (set in the 
  fields information file) and the cosmological parameters {\tt OMEGA\_m}, {\tt OMEGA\_L} and 
  {\tt W\_de}. The option {\tt SELEC\_TYPE: 1} is currently not fully implemented. On top of these 
  two options, the user can specify that the angular part of the selection function is only 
  used for bookkeeping (that is, it does not affect the number of galaxies generated and the 
  simulation is actually full sky) by adding 2 to choice made, leading to the following possible 
  options for {\tt SELEC\_TYPE}: {\tt 0}, {\tt 1}, {\tt 2} and {\tt 3}. Currently the bookkeeping 
  option only works for separable selection functions. 

\item {\tt STARMASK:} Besides the selection function specified in {\tt SELEC\_PREFIX}, the user 
  can multiply the selection function by a {\sc healpix} map in FITS file format, passed to this 
  keyword. All selection functions are affected by this angular mask. In the current implementation, 
  this map must have the same $N_{\nv{side}}$ as the one passed to the {\tt NSIDE} keyword.
  To not use this extra angular selection function, the user can set {\tt STARMASK: 0}.

\item {\tt EXTRAP\_DIPOLE:} Many power spectra calculators like 
  {\sc class}\footnote{\tt{\href{http://class-code.net/}{http://class-code.net/}}} or 
  {\sc camb sources}\footnote{\tt{\href{http://camb.info/sources}{http://camb.info/sources}}} 
  write $C(\ell)$s for $\ell\geq 2$. If this keyword is set to {\tt 1}, then the dipole $C(\ell=1)$, 
  if missing, is linearly extrapolated from $C(\ell=2)$; otherwise, if {\tt EXTRAP\_DIPOLE: 0} and the 
  dipole is missing, then the dipole is set to zero (NOTE: the monopole is always set to zero).

\item {\tt LRANGE:} This takes two integers separated by space representing the minimum 
  $\ell_{\nv{min}}$ and maximum $\ell_{\nv{max}}$, respectively, that will be used to generate the 
  associated Gaussian multipoles. They should obey $1 \leq \ell_{\nv{min}} \leq \ell_{\nv{max}} \leq \ell_{\nv{in}}$, 
  where $\ell_{\nv{in}}$ is the highest $\ell$ provided in the input power spectra.

\item {\tt CROP\_CL:} The transformation from lognormal to auxiliary Gaussian fields' $C_\ell$s
  \citep[Eq. 21]{Xavier16mn} needs, in theory, all multipoles $\ell'$ of the input $C_\ell$s, up to 
  infinity. In practice, {\sc flask} uses truncated $C_\ell$s and this might cause the lognormal realizations  
  to follow slightly different $C_\ell$s at large $\ell$. At this stage, there are two options. 
  If {\tt CROP\_CL: 0}, the transformation will be performed using all the multipoles provided in the 
  input $C_\ell$ files. Otherwise, if {\tt CROP\_CL: 1}, {\sc flask} will only use in the transformartion 
  the multipoles up to the $\ell_{\nv{max}}$ set in the {\tt LRANGE} keyword. This last option seem to 
  provide better results, but this could vary from case to case. Note that regardless the choice of 
  {\tt CROP\_CL}, the realizations are generated from the multipoles specified in {\tt LRANGE}. 

\item {\tt SHEAR\_LMAX:} The shear is derived from the convergence multipoles using the equations 
  from \citet{Hu00x} and the $E$-mode definition from {\sc healpix} manual. In Gaussian simulations 
  the shear multipoles are derived from the original convergence multipoles used to generate the maps; 
  this is not possible in lognormal simulations since the convergence was generated from multipoles of the 
  associated Gaussian field (a similar argument exists for convergences obtained from density LoS integration). 
  Therefore, to compute the shear from lognormal (or density LoS integration) convergences one needs first to 
  obtain their multipoles. The {\tt SHEAR\_LMAX} keyword takes one integer representing 
  the maximum multipole that will be extracted from the lognormal convergence maps for this purpose (thus it 
  does not affect Gaussian simulations) and the maximum multipole that will be available in shear maps. 
  Using {\tt SHEAR\_LMAX} $>$ {\tt NSIDE} introduces noise in this transformation.
  
\item {\tt NSIDE:} This takes an integer representing the {\sc healpix} $N_{\nv{side}}$ parameter. 
  The number of pixels $N_{\nv{pix}}$ used in each redshift slice is $N_{\nv{pix}}=12N_{\nv{side}}^2$. 
  Any number can be provided here, although some external applications (e.g. anything based 
  in {\sc healpy}) only accepts powers of 2.

\item {\tt USE\_HEALPIX\_WGTS:} This keyword states if the code should use ({\tt 1}) or not ({\tt 0}) 
  the {\sc healpix} weights to perform the {\tt map2alm} (harmonic transform) operation. The 
  weights are only available for $N_{\nv{side}}=2^n$, where $n\in \mathbb{N}$. If 
  {\tt USE\_HEALPIX\_WGTS: 0}, the weights will all be set to unity.

\item {\tt MINDIAG\_FRAC:} This keyword takes a real number $f$. If $f>0$, any null diagonal term in 
  the auxiliary (Gaussian) covariance matrices (that can be output by {\tt COVL\_PREFIX}) is set to $f$ times the 
  smallest diagonal term greater than zero in all auxiliary covariance matrices (any $\ell$). If this 
  is set to zero or less, nothing happens. This allows for {\tt HOMOGENEOUS} fields to be simulated 
  along with {\tt LOGNORMAL} or {\tt GAUSSIAN} ones.

\item {\tt BADCORR\_FRAC:} This takes a real number $f$. In case some covariance matrix entries 
  lead to forbidden correlations $\rho_{ij}$ ($\rho_{ij}>1$ or $\rho_{ij}<-1$), {\sc flask} will 
  add this fractional change to both variances related to the forbidden correlation: 
  $v_i^{\nv{new}} = (1+f)v_i^{\nv{old}}$ and $v_j^{\nv{new}} = (1+f)v_j^{\nv{old}}$.

\item {\tt REGULARIZE\_METHOD:} In case some associated Gaussian multipoles covariance matrix 
  is non-positive-definite, {\sc flask} can make it positive-definite by changing its entries. 
  There are two methods currently implemented for that, described in \citet{Xavier16mn}: option 
  {\tt REGULARIZE\_METHOD: 1} performs an eigendecomposition of the matrix and sets the negative eigenvalues to a 
  new value specified by {\tt NEW\_EVAL}; option {\tt REGULARIZE\_METHOD: 2} looks for a direction of greatest 
  change in the negative eigenvalues and apply successive distortions (up to {\tt REG\_MAXSTEPS} 
  times) of size given by {\tt REGULARIZE\_STEP} in that direction, until all eigenvalues are positive. You may set 
  {\tt REGULARIZE\_METHOD: 0} to make {\sc flask} abort in case of non-positive-definite matrices. 

\item {\tt NEW\_EVAL:} This takes a real number. If {\tt REGULARIZE\_METHOD} is set to {\tt 1}, 
  covariance matrices negative eigenvalues will be replaced by this value. This value is not used 
  for other {\tt REGULARIZE\_METHOD} options.

\item {\tt REGULARIZE\_STEP:} This takes a real number. If {\tt REGULARIZE\_METHOD} is set to {\tt 2},
  this will be the size of the step taken in the direction in the covariance matrix elements space that 
  changes the negative eigenvalues the most.  This value is not used for other {\tt REGULARIZE\_METHOD} 
  options.
  
\item {\tt REG\_MAXSTEPS:} This takes an integer number that specifies the maximum amount of 
  steps taken in the covariance matrix elements space when trying to regularise the matrix 
  with {\tt REGULARIZE\_METHOD: 2}. This value is not used for other {\tt REGULARIZE\_METHOD} 
  options. 

\item {\tt ADD\_FRAC:} If the covariance matrix regularisation fails or if it succeeds but the 
  Cholesky decomposition still fails, {\sc flask} will take the real value passed to this keyword, 
  multiply by the smallest element of the covariance matrix's diagonal and add the result to all 
  diagonal elements of that matrix. 

\item {\tt ZSEARCH\_TOL:} When building the galaxy catalogue, {\sc flask} will randomly select 
  a redshift inside the galaxy's redshift slice according to the selection function. To do that, 
  it has to find the selection function local maximum inside the redshift bin. The real value 
  passed to {\tt ZSEARCH\_TOL} specifies the precision in redshift to which the maximum is found.

\item {\tt EXIT\_AT:} This keyword takes a string that must be either {\tt 0} or any other keyword
  that specifies an output (without the colon, case sensitive). The code will stop right after 
  the point where that output is produced, even if it is not set to be produced. If {\tt EXIT\_AT: 0}, 
  {\sc flask} will run until the end. The output keywords in the {\tt example.config} file 
  are ordered just like they are produced.

\item {\tt FITS2TGA:} This can take the options: {\tt 0}, all {\sc healpix} map outputs remain only 
  in {\sc healpix} map FITS format; {\tt 1}, all {\sc healpix} map outputs also result in a TGA
  image format version; {\tt 2}, all {\sc healpix} map outputs are transformed into TGA images.

\item {\tt USE\_UNSEEN:} This keyword takes either {\tt 0} or {\tt1}. In the first case, all masked 
  pixels in {\sc healpix} map or text file outputs (e.g. {\tt MAPWER\_OUT} and 
  {\tt MAPWERFITS\_PREFIX}) are set to zero; in the second case, all such pixels are 
  set to {\sc healpy}'s UNSEEN value ($-1.6375\times10^{30}$).

\item {\tt LRANGE\_OUT:} This takes to integers separated by space, representing the minimum and 
  maximum $\ell$s that will be output in any $C(\ell)$ or $a_{\ell m}$ outputs; this range does 
  not affect calculations, only outputs, and it has to be included in the range set by {\tt LRANGE}.
  
\item {\tt MMAX\_OUT:} This takes an integer. In $a_{\ell m}$ outputs, the multipoles will all 
  be written out if this is set to a negative number. If this is set to $m_{\nv{max}}$, only $a_{\ell m}$s 
  with $m\leq m_{\nv{max}}$ will be written. In the current implementation, $m_{\nv{max}}$ must be less than 
  or equal to the minimum $\ell$ specified in {\tt LRANGE\_OUT}.

\item {\tt ANGULAR\_COORD:} This can take three options: {\tt 0}, all text outputs referring 
  to angular positions will use the polar and azimutal angles $\theta$ and $\phi$, given in radians, 
  as angular coordinates ({\sc healpix} style); {\tt 1}, these outputs will use $\theta$ and $\phi$ 
  in degrees; {\tt 2}, these outputs will use right ascension and declination in degrees as 
  angular coordinates. This choice does not affect {\tt XIOUT\_PREFIX} and {\tt GXIOUT\_PREFIX} 
  outputs which are always in degrees. For the catalogue output given by {\tt CATALOG\_OUT}, 
  with columns specified by {\tt CATALOG\_COLS}, the choice between right ascension and declination and 
  polar and azimutal angles is overridden by {\tt CATALOG\_COLS}; the choice between radians and degrees 
  for $\theta$ and $\phi$, performed with {\tt ANGULAR\_COORD}, still applies.

\item {\tt DENS2KAPPA:} If set to {\tt 1}, {\sc flask} computes a convergence field by integrating 
  the matter density fields along the line of sight \citep[see][for details]{Xavier16mn}. This 
  option requires that density fields in the fields information file are specified in contiguous 
  and ordered redshift bins. The resulting convergence fields are added to the field list and from 
  now on are treated the same way as ordinary convergence fields. If {\tt DENS2KAPPA} is set to {\tt 0}, 
  no integration is performed and no new convergence is computed. 

\item {\tt FLIST\_OUT:} This keyword takes a string. If anything other than {\tt 0}, the code 
  treat it as a filename and writes the list of fields in use by the code to this file. 

\item {\tt SMOOTH\_CL\_PREFIX:} Path plus prefix for the power spectra output, after re-scaling 
  the input $C^{ij}(\ell)$s by {\tt SCALE\_CLS} and applying the Gaussian window function according to 
  {\tt WINFUNC\_SIGMA}, the {\sc healpix} pixel window function according to {\tt APPLY\_PIXWIN} 
  and the exponential suppression according to {\tt SUPPRESS\_L} and {\tt SUP\_INDEX} 
  keywords. Set to {\tt 0} for no output.

  If the string passed to {\tt SMOOTH\_CL\_PREFIX} ends in {\tt .dat}, all $C^{ij}(\ell)$s will 
  be written to a single file instead of individual files. 

\item {\tt XIOUT\_PREFIX:} Path with prefix for angular correlation functions $\xi^{ij}(\theta)$, 
  written as two column (angle $\theta$ in degrees and $\xi^{ij}(\theta)$) text files. 
  Currently it can only be calculated if {\tt DIST: LOGNORMAL} and there is no option of 
  outputting all $\xi^{ij}(\theta)$ to a single {\tt .dat} file. Set to {\tt 0} for no output. 
  

\item {\tt GXIOUT\_PREFIX:} Path, including a prefix, for angular correlation functions 
  $\xi^{ij}_{\nv{g}}(\theta)$ of the associated Gaussian fields, written as two column 
  (angle $\theta$ in degrees and $\xi^{ij}_{\nv{g}}(\theta)$) text files. This is only calculated if the 
  input fields are lognormal. Set to {\tt 0} for no output. Currently there is no option of 
  outputting all $\xi^{ij}(\theta)$ to a single {\tt .dat} file.

\item {\tt GCLOUT\_PREFIX:} Prefix (including path) for angular power spectra $C_{\nv{g}}^{ij}(\ell)$ 
  of the associated Gaussian fields. This is only calculated if {\tt DIST: LOGNORMAL}. 
  Set to {\tt 0} for no output. Currently there is no option of 
  outputting all $\xi^{ij}(\theta)$ to a single {\tt .dat} file.

\item {\tt COVL\_PREFIX:} Path plus prefix for the Gaussian $a^{i}_{\ell m}$s covariance matrices 
  [for a fixed $\ell$, $C_{\nv{g}}^{ij}(\ell)$ is the element $(i,j)$ of the covariance matrix]. 
  Set to {\tt 0} for no output.

\item {\tt REG\_COVL\_PREFIX:} Path with prefix for the covariance matrices that would be output 
  by {\tt COVL\_PREFIX} but after being regularised according to the choice in {\tt REGULARIZE\_METHOD}.
  Set to {\tt 0} for no output.

\item {\tt REG\_CL\_PREFIX:} Prefix (including path) for the regularised input $C^{ij}(\ell)$s. 
  In case {\tt DIST: LOGNORMAL}, the $C^{ij}(\ell)$s output here are for the lognormal fields, not for 
  the auxiliary Gaussian fields. For no output, set this keyword to {\tt 0}. If the string passed to 
  this keyword ends in {\tt .dat}, all regularized $C^{ij}(\ell)$s are written to a single file. 
  Note that the order the $C^{ij}(\ell)$s appear in this file will follow the order in the fields 
  information file passed to {\tt FIELDS\_INFO}, not the order in the file passed to {\tt CL\_PREFIX}. 

\item {\tt CHOLESKY\_PREFIX:} Path plus prefix for the outcome of the Cholesky decomposition 
  as implemented by the \emph{GNU Scientific Library} 
  (GSL).\footnote{ Check {\tt \href{ http://www.gnu.org/software/gsl/manual/html\_node/Cholesky-Decomposition.html}{http://www.gnu.org/software/gsl/manual/html\_node/Cholesky-Decomposition.html}} for details.} Set to {\tt 0} for no output. 
  These files can be passed as input to {\sc flask} by using the keyword {\tt CHOL\_IN\_PREFIX}.
  
\item {\tt AUXALM\_OUT:} Filename (with path) for the table with multipoles coefficients 
  $a^{i}_{\ell m}$ of every associated Gaussian field and redshift slice $i$ being simulated. 
  Since the fields are real, only $a^{i}_{\ell m}$ with $m\geq 0$ are written.
  Set to {\tt 0} for no output.

\item {\tt RECOVAUXCLS\_OUT:} Filename (with path) for the table with $C^{ij}(\ell)$s recovered 
  from the realized $a^{i}_{\ell m}$s of the associated Gaussian fields (see {\tt AUXALM\_OUT} keyword). 
  The computation is performed according to Eq. \ref{eq:recov-cl}. Set to {\tt 0} for no output.

\item {\tt AUXMAP\_OUT:} Filename (with path) for a text table containing the pixel's centre angular 
  coordinates and the values at that point of every associated Gaussian field at every redshift slice 
  being simulated. Set to {\tt 0} for no output.

\item {\tt DENS2KAPPA\_STAT:} This can be set to {\tt 0} for no output, to {\tt 1} for output 
  on the screen, or to a filename in case the user wants the output to be written to a file. 
  The output is a table with statistical properties of the convergence obtained from density 
  LoS integration. This information is only produced if {\tt DENS2KAPPA: 1}.

\item {\tt MAP\_OUT:} Path plus filename for a text table containing the pixel's centre angular 
  coordinates and the values at that point of every field (Gaussian or lognormal, according to 
  {\tt DIST}) at every redshift slice being simulated. This does not include the selection function 
  nor noise apart from cosmic variance. Set to {\tt 0} for no output. 

\item {\tt MAPFITS\_PREFIX:} Prefix (including path) for a {\sc healpix} map FITS file for each 
  simulated field and redshift slice. The output format can be altered by {\tt FITS2TGA}. This does not include 
  the selection function nor noise apart from cosmic variance. Set to {\tt 0} for no output. 
  
\item {\tt RECOVALM\_OUT:} Path plus filename for a text table of multipole coefficients 
  $a^{i}_{\ell m}$ recovered, using the {\tt map2alm} {\sc healpix} function, 
  from the maps that can be output by {\tt MAP\_OUT} and 
  {\tt MAPFITS\_PREFIX}. Set to {\tt 0} for no output. 

\item {\tt RECOVCLS\_OUT:} Path plus filename for a text table of power spectra 
  $C_{\nv{rec}}^{ij}(\ell)$ recovered from the maps that can be output by {\tt MAP\_OUT} and 
  {\tt MAPFITS\_PREFIX}. In other words, $C_{\nv{rec}}^{ij}(\ell)$ is the average over $m$ 
  of $a^{i}_{\ell m}a^{j*}_{\ell m}$, where $a^{i}_{\ell m}$ can be output by {\tt RECOVALM\_OUT} (see Eq. \ref{eq:recov-cl}). 
  Set to {\tt 0} for no output. 

\item {\tt SHEAR\_ALM\_PREFIX:} Prefix (including path) for files containing the weak lensing 
  shear $E$-mode multipole coefficients $a^{i}_{\ell m}$, one for each lensing field and redshift 
  slice. Set to {\tt 0} for no output. 

\item {\tt SHEAR\_FITS\_PREFIX:} Prefix (including path) for {\sc healpix} maps 
  of weak lensing attributes, obtained from lensing $a_{\ell m}$s ($E$-modes that can be 
  output by {\tt SHEAR\_ALM\_PREFIX}) by the {\sc healpix} function {\tt alm2map\_spin}. 
  These FITS files contain three columns: convergence $\kappa$ and shear components 
  $\gamma_1$ and $\gamma_2$. This does not include the selection function nor noise apart 
  from cosmic variance. Set to {\tt 0} for no output. 

\item {\tt SHEAR\_MAP\_OUT:} Path plus filename for a text table containing the pixel's 
  centre angular coordinates and the values at that point of the two shear components  
  $\gamma_1$ and $\gamma_2$ of every weak lensing field at every redshift slice. 
  This does not include the selection function nor noise apart from cosmic variance. 
  Set to {\tt 0} for no output. 

\item {\tt MAPWER\_OUT:} Path plus filename for a text table containing the pixel's 
  centre angular coordinates and the values at that point of the fields after applying 
  the selection function and sampling (see {\tt POISSON} keyword) the galaxy density fields; that is, the 
  values are the number of galaxies in each pixel in each redshift slice (i.e. in each 
  cell). In the current implementation, convergence fields do not get any noise contribution 
  apart from cosmic variance and are masked out according to the angular selection 
  function (see Sec. \ref{sec:selection} for possible exceptions). Set to {\tt 0} for no output. 

\item {\tt MAPWERFITS\_PREFIX:} Prefix (including path) for the {\sc healpix} maps version 
  of the {\tt MAPWER\_OUT} output, one file per field per redshift slice. Set to {\tt 0} for no output. 

\item {\tt ELLIP\_MAP\_OUT:} This keyword takes a path plus a filename for a text table 
  describing the ellipticity inside pixels centered at the angular coordinates specified 
  in the file. The file will contain two columns (the two components of the complex 
  ellipticity) for each galaxy field in each redshift slice where lensing fields 
  are also specified. The ellipticity in each pixel is given by Eq. \ref{eq:ellip-map-noise}, 
  where $N_{\nv{gal}}(j)$ is given by the Poisson sampled number (or the expected number if 
  {\tt POISSON: 0}, or Gaussian sampled number if {\tt POISSON: 2}) of galaxies (of that type, if simulating 
  more than one tracer) in the pixel; if $N_{\nv{gal}}(j)\leq 0$, the pixel is masked out (i.e. it gets 
  the value specified by the {\tt USE\_UNSEEN} keyword). 

  If there are no galaxy fields being simulated, {\sc flask} will require that 
  a selection function is assigned to the lensing field and this will be assumed 
  to be the sources' selection function. Since in this case the sources are not Poisson 
  sampled, $N_{\nv{gal}}(j)=\langle N_t(i,j) \rangle = \bar{n}_t(i,j)\Delta\Omega$ 
  (see Sec. \ref{sec:selection}). Pixels were the selection function is equal to or 
  less than zero are masked out. You can set this keyword to {\tt 0} for no output.
  
\item {\tt ELLIPFITS\_PREFIX:} This keyword takes a path plus a prefix for a set of 
  {\sc healpix} maps that are written out, each one describing an ellipticity field for a certain tracer and 
  at a certain redshift, just like the columns described in the {\tt ELLIP\_MAP\_OUT} 
  keyword. Each {\tt .fits} file contains three maps: the last two are the two components 
  of the ellipticity for that tracer at that redsfhit and the first one is the same convergence map 
  as the one generated by the {\tt MAPWER\_OUT} keyword, at the same redshift. 
  You can set this keyword to {\tt 0} for no output.

\item {\tt CATALOG\_OUT:} Path plus filename for a galaxy catalogue in text, FITS or compressed
  FITS formats, chosen accordingly to the filename extension: {\tt .dat}, {\tt .fits} or {\tt .fits.gz}, 
  respectively. Each row is one galaxy from the map described in {\tt MAPWER\_OUT} and 
  the columns are chosen by the user using the {\tt CATALOG\_COLS} keyword. Set to {\tt 0} for no output.

\item {\tt CATALOG\_COLS:} This takes as input everything in the same line of the configuration 
  file after it, and it specifies the columns to be included in the galaxy catalogue output by 
  {\tt CATALOG\_OUT}. They can be: 
  \begin{itemize}
  \item {\tt theta}, the polar angle $\theta$ of the galaxy position given in units according to 
    {\tt ANGULAR\_COORD}, randomly sampled inside the corresponding pixel; 
  \item {\tt phi}, the azimutal angle $\phi$ of the galaxy position given in units according to 
    {\tt ANGULAR\_COORD}, randomly sampled inside the corresponding pixel;
  \item {\tt ra}, the right ascension given in degrees;
  \item {\tt dec}, the declination given in degrees (the choice of angular coordinates is exclusive, 
    one cannot mix different coordinate systems in the catalogue, e.g. {\tt dec} and {\tt phi} or 
    {\tt dec} and {\tt theta});
  \item {\tt z}, the galaxy's redshift, which is randomly sampled inside the corresponding cell 
    according to the selection function;
  \item {\tt r}, the comoving distance, given in $h^{-1}\mathrm{Mpc}$, associated to 
    the galaxy's redshift {\tt z} above, according to the formula:
    \begin{equation}
      r = \frac{c}{H_{100}}
      \int_0^z\frac{\mathrm{d}z'}{\sqrt{\Omega_{\mathrm{m}}(1+z')^3+\Omega_{\mathrm{k}}(1+z')^2+\Omega_{\mathrm{L}}(1+z')^{3(1+w_{\mathrm{de}})}}}, 
      \label{eq:comdist}
    \end{equation}
    where: $H_{100}=100\mathrm{\:m\:s^{-1}\:Mpc^{-1}}$, $\Omega_{\mathrm{k}}=1-\Omega_{\mathrm{m}}-\Omega_{\mathrm{L}}$; and 
    $\Omega_{\mathrm{m}}$, $\Omega_{\mathrm{L}}$ and $w_{\mathrm{de}}$ are given by the keywords 
    {\tt OMEGA\_m}, {\tt OMEGA\_L} and {\tt W\_de}. Therefore, the interpretation of {\tt r} depends on what 
    is being simulated, e.g. if the input power spectra includes redshift space distortions, {\tt r} 
    will be the distance in redshift space. 
  \item {\tt galtype}, i.e. the field's name as in the fields information file, see Sec. \ref{sec:fields-info}; 
  \item {\tt kappa}, the convergence $\kappa$ at the corresponding cell (pixel and redshift slice);
  \item {\tt gamma1}, the first component of the shear, $\gamma_1$, at the corresponding cell;
  \item {\tt gamma2}, the second component of the shear, $\gamma_2$, at the corresponding cell; 
  \item {\tt ellip1}, the first component of the ellipticity of the galaxy $\epsilon_1$, 
    given by Eq. \ref{eq:ellipticity}; 
  \item {\tt ellip2}, the second component of the ellipticity of the galaxy $\epsilon_2$, 
    given by Eq. \ref{eq:ellipticity};
  \item {\tt pixel}, the {\sc healpix} map pixel number of the corresponding cell; 
  \item {\tt maskbit}, returns a sum of the following integers: 1 if the galaxy would 
    be removed by the angular selection function, i.e., if the angular selection function value 
    at the corresponding pixel is zero or less; 2 if the galaxy would be removed by the star mask 
    given by {\tt STARMASK}, i.e., if the star mask value at the corresponding pixel is zero or less; 
    4 if the angular selection function value $s$ obeys $0<s<1$ (only if the selection function is 
    separable); 8 if the star mask value $m$ obeys $0<m<1$; 16 if the angular selection 
    function value $s$ is $s>1$ (only if the selection function is separable); and 32 
    if the star mask value $m$ is $m>1$. For instance, a {\tt maskbit} of 0 means that the galaxy would be observed 
    while a {\tt maskbit} of 3 means that the galaxy would be blocked both by the angular selection
    function and the star mask.
  \end{itemize}
  The column names have to be separated by spaces and they can appear in any number (no repeated 
  columns, though) and order.
\end{itemize}


\subsection{Fields information file}
\label{sec:fields-info}

The fields information file is a text file that informs {\sc flask} the fields and redshift 
slices it should simulate, along with their properties. In the current implementation, these 
files can have any number of lines serving as headers (that should always start with a {\tt \#}). 
Empty lines can also appear before the tabular data, but they cannot contain spaces. Once 
the tabular data appears, you should stick to it. The file can end at the last data line or 
with an empty line (no spaces allowed). An example of such file is given in Fig. \ref{fig:fields-info}.

\begin{alltt}
\begin{center}
\begin{boxedverbatim}
# Field number, z bin number, mean, shift, field type, zmin, zmax
# Types: 1-galaxies 2-lensing

     1      1   0.0000   1.0000      1   0.2500   0.3500
     1      2   0.0000   1.0000      1   0.3500   0.4500
     1      3   0.0000   1.0000      1   0.4500   0.5500
     2      1   0.0000   0.0050      2   0.2500   0.3500
     2      2   0.0000   0.0084      2   0.3500   0.4500
     2      3   0.0000   0.0126      2   0.4500   0.5500
\end{boxedverbatim}
\captionof{figure}{Example of a fields information file with two fields (one of type 
  \emph{galaxy} or \emph{matter density} and the other of type \emph{weak lensing 
    convergence}) in three redshift slices. The column order is summarised in the header.
\label{fig:fields-info}}
\end{center}
\end{alltt}

The fields information file columns must be, in this order:
\begin{itemize}
\item An arbitrary natural number ``naming'' the field (for multi-tracer simulations, they can identify 
  different galaxy populations).
\item An arbitrary natural number ``naming'' the redshift slice.
\item The fields mean value at that redshift slice, usually zero (for density contrast and convergence, for instance);
\item The fields shift parameter, if the field is lognormal (in case of a Gaussian simulation, this column 
  still have to be present but it will be ignored).
\item The field type, which determines how the field is treated inside the code. In the current 
  implementation, this can be either 1 (CMB or gas temperature, matter density or matter density tracers like 
  galaxies, quasars, etc.) or 2 (weak lensing convergence). These types affect how {\sc flask} deals with 
  selection functions, noise and field transformations. For details, one can look for {\tt flensing} and 
  {\tt fgalaxies} in the code using the command {\tt grep}.
\item The lower boundary of the redshift slice;
\item and the upper boundary of the redshift slice. The redshift slices may overlap, have any size and ordering 
  (unless you are integrating the density, see the {\tt DENS2KAPPA} keyword in Sec. \ref{sec:keywords}). 
  In the current implementation, these are only used in the density LoS integration controlled by the {\tt DENS2KAPPA}, 
  to Poisson sample the density fields or to compute shape noise for galaxy ellipticity maps according to 
  Eq. \ref{eq:ellip-map-noise}; in all cases, the redshift slice is assumed to be a top-hat 
  redshift window function. If you are not performing these operations, these redshift boundaries are 
  irrelevant and the slices can present arbitrary redshift window functions (e.g. Gaussians), according to 
  the power spectra provided as input.
\end{itemize}

To simulate the fields and redshift slices mentioned in a fields information file, 
{\sc flask} requires their auto power spectra and all cross power spectra (unless 
the keyword {\tt ALLOW\_MISS\_CL} is set to {\tt 1}). Each power spectrum has to 
be in a file with prefix given by the keyword {\tt CL\_PREFIX} followed by 
{\tt f}$[f_i]${\tt z}$[z_i]${\tt f}$[f_j]${\tt z}$[z_j]${\tt .dat}, where 
$[f_i]$ and $[z_i]$ are the numbers (no zero-padding allowed) in the first and 
second columns of the fields information file. For instance, if 
the configuration file have {\tt CL\_PREFIX:} {\tt data/testCl-} and 
{\tt FIELDS\_INFO} referring to the file in Fig. \ref{fig:fields-info}, 
{\sc flask} will look for the files:

\begin{alltt}
\begin{center}
\begin{tabular}{cc}
 data/testCl-f1z1f1z1.dat & data/testCl-f2z1f1z1.dat \\
 data/testCl-f1z1f1z2.dat & data/testCl-f2z1f1z2.dat \\ 
 data/testCl-f1z1f1z3.dat & data/testCl-f2z1f1z3.dat \\
 data/testCl-f1z1f2z1.dat & data/testCl-f2z1f2z1.dat \\
 data/testCl-f1z1f2z2.dat & data/testCl-f2z1f2z2.dat \\
 data/testCl-f1z1f2z3.dat & data/testCl-f2z1f2z3.dat \\
 data/testCl-f1z2f1z1.dat & data/testCl-f2z2f1z1.dat \\
 data/testCl-f1z2f1z2.dat & data/testCl-f2z2f1z2.dat \\
 data/testCl-f1z2f1z3.dat & data/testCl-f2z2f1z3.dat \\
 data/testCl-f1z2f2z1.dat & data/testCl-f2z2f2z1.dat \\
 data/testCl-f1z2f2z2.dat & data/testCl-f2z2f2z2.dat \\
 data/testCl-f1z2f2z3.dat & data/testCl-f2z2f2z3.dat \\
 data/testCl-f1z3f1z1.dat & data/testCl-f2z3f1z1.dat \\
 data/testCl-f1z3f1z2.dat & data/testCl-f2z3f1z2.dat \\
 data/testCl-f1z3f1z3.dat & data/testCl-f2z3f1z3.dat \\
 data/testCl-f1z3f2z1.dat & data/testCl-f2z3f2z1.dat \\
 data/testCl-f1z3f2z2.dat & data/testCl-f2z3f2z2.dat \\
 data/testCl-f1z3f2z3.dat & data/testCl-f2z3f2z3.dat \\
\end{tabular}
\end{center}
\end{alltt}
However, since the cross power spectra are symmetric 
({\tt testCl-f}$[f_i]${\tt z}$[z_i]${\tt f}$[f_j]${\tt z}$[z_j]${\tt .dat} $=$ 
 {\tt testCl-f}$[f_j]${\tt z}$[z_j]${\tt f}$[f_i]${\tt z}$[z_i]${\tt .dat} ), 
{\sc flask} only requires 21 of the files listed above.

In case you use {\sc class}\footnote{\tt{\href{http://class-code.net/}{http://class-code.net/}}} 
\citep{Blas11x, Dio13x} or 
{\sc camb sources}\footnote{\tt{\href{http://camb.info/sources}{http://camb.info/sources}}}
\citep{Challinor11x} to compute the input power spectra, it is possible to use the 
{\sc python} scripts called {\tt class2info.py} and {\tt camb2info.py} in {\sc flask}'s 
{\tt src/scripts} folder to create the fields information file corresponding to {\sc class} and 
{\sc camb sources} input ({\tt .ini}) files. See Sec. \ref{sec:aux} and the scripts' docstring for more information.

Since March 2019, it is also possible to pass a single file ending by {\tt .dat} to 
{\tt CL\_PREFIX} containing all required power spectra. See Sec. \ref{sec:cls} for 
more details. 


\subsection{Angular power spectra files}
\label{sec:cls}

Apart from the distribution's PDF -- determined by the {\tt DIST} keyword in 
the configuration file -- and the fields mean and shift parameters in the fields 
information file, all statistical properties of the simulated fields are fixed 
by the input angular power spectra $C_{\nv{in}}^{ij}(\ell)$, including their 
cross-correlations. All characteristics 
such as: tracer biases with respect to matter density; redshift space distortions; 
galaxy intrinsic alignments; integrated Sachs-Wolfe effect; tracer evolution with 
redshift; and magnification bias can be included in the simulations by providing the 
appropriate $C_{\nv{in}}^{ij}(\ell)$ with such information encoded in them. The 
step of computing these power spectra is not part of {\sc flask} and is left to the user. 
Some public codes available to perform such calculations are: 
{\sc class}\footnote{\tt{\href{http://class-code.net/}{http://class-code.net/}}} 
\citep{Blas11x, Dio13x} and 
{\sc camb sources}\footnote{\tt{\href{http://camb.info/sources}{http://camb.info/sources}}}
\citep{Challinor11x}.

In the current implementation, the $C_{\nv{in}}^{ij}(\ell)$s can be passed to {\sc flask} in two ways:
\begin{itemize}
\item As individual files: these must be named as explained in \ref{sec:fields-info} and must 
have two columns: $\ell$ and $C_{\nv{in}}^{ij}(\ell)$ (no headers allowed here). The $C_{\nv{in}}^{ij}(\ell)$ 
is the power spectra itself and not something like 
$l(l+1)/(2\pi)\cdot C_{\nv{in}}^{ij}(\ell)$. They are interpolated by the code so it is not necessary 
to specify them at every $\ell$ or at integer $\ell$s. For the user's convenience, {\sc python} 
scripts called {\tt prepClassInput.py} and {\tt prepCambInput.py} are available in {\sc flask}'s 
{\tt src/scripts} folder that can translate {\sc class} and {\sc camb sources} output power spectra 
into {\sc flask} input power spectra. See Sec. \ref{sec:aux} and the scripts' docstring for more information. 

\item As a table in a single file (ending by {\tt .dat}): the first column must be $\ell$ 
and the following ones the  $C_{\nv{in}}^{ij}(\ell)$s. In the example given by 
Fig. \ref{fig:fields-info}, we could have something like {\tt CL\_PREFIX:} 
{\tt data/testCl.dat} in the configuration file, and this file would contain 
22 columns [the first one for $\ell$ and the remaining ones for the 21 required 
$C^{ij}(\ell)$s]. This file must have a header starting with {\tt \#}, followed 
by column labels separated by spaces. The labels of the power spectra columns must 
contain the pattern $[f_i]${\tt z}$[z_i]${\tt f}$[f_j]${\tt z}$[z_j]$ indicating 
to which field and redshift slice pairs they correspond to.
\end{itemize}

\section{Auxiliary codes}
\label{sec:aux} 

There are several smaller routines available in {\sc flask}'s directory that can help the user prepare 
its inputs and visualise or organise its outputs. Here we list the most important of them. More information 
can be found on their docstrings. 

\subsection{{\tt Dens2KappaCls}}
\label{sec:dens2kappacls}

This is a C++ code compiled to the {\tt bin} sub-directory that takes the input power spectra and 
configuration file that would be used by {\sc flask} and compute the expected power spectra that 
would be recovered from convergence computed by integrating simulated lognormal densities along 
the line of sight (i.e., this code computes the red solid lines in Fig. 15 of \citet{Xavier16mn}. 

The {\tt Dens2KappaCls} usage is similar to that of {\sc flask}: you run it by invoking the 
executable followed by the path to the configuration file, followed by keywords you want to 
change. The difference is that the last parameter passed to {\tt Dens2KappaCls} must be the 
output files prefix for the $C(\ell)$s of the convergence obtained from density LoS integration, 
for instance:

\noindent
{\tt Dens2KappaCls example.config NSIDE: 128 output/kappaCl-}

Although this code takes the same configuration file as {\sc flask} and will complain if any 
keyword is missing, the only keywords it actually uses are: {\tt FIELDS\_INFO}, 
{\tt CL\_PREFIX}, {\tt ALLOW\_MISS\_CL}, {\tt OMEGA\_m}, {\tt OMEGA\_L} and 
{\tt W\_de} (therefore, changing {\tt NSIDE} in the example 
above is a bit silly).

In the current version, {\tt Dens2KappaCls} does not apply any window function or suppression 
to the input $C(\ell)$s before integrating them. In case you want to compare its output with 
recovered $C(\ell)$s from {\sc flask} and have applied any of these changes to the {\sc flask} \
input power spectra, you should use the {\tt SMOOTH\_CL\_PREFIX} keyword in {\sc flask} to 
output files to be used as input here.

\subsection{{\tt GenStarMask}}
\label{sec:genstarmask}

This routine, written in C++, creates a full-sky random star mask with parameters given by the user and 
then outputs it to a {\sc healpix} map in FITS format. The parts without stars have value 1 and 
the parts with stars (which are modelled as disks) have value 0. If necessary, these values 
can be changed in the source code by redefining the {\tt StarValue} and {\tt EmptyValue} 
variables.

{\tt GenStarMask} takes 6 inputs, in this order: a integer used as seed for random numbers; 
the $N_{\nv{side}}$ {\sc healpix} resolution parameter; a minimum angular radius for the stars $r_{\nv{min}}$, given 
in arcmin; a maximum angular radius for the stars $r_{\nv{max}}$, given in arcmin; the sky fraction to be covered 
by stars; and the filename for the output.

The stars (modelled as disks) are distributed homogeneously on the sky, and the natural 
logarithmic of the disk radius are homogeneously sampled between $\nv{ln}(r_{\nv{min}})$ and 
$\nv{ln}(r_{\nv{max}})$. The stars can be superimposed and are generated until the fraction of 
pixels covered by stars is greater than the value specified in the input.

\subsection{{\tt camb2info.py}}
\label{sec:camb2info}

This {\sc python} script takes a {\sc camb sources} input file and creates a 
{\sc flask} fields information file. It takes as input, in this order: 
the {\sc camb sources} {\tt .ini} filename and the output filename. 

There are three methods for computing the shift parameter for convergence:
a table read from a file which is interpolated; the formula from 
\citet{Hilbert11x}; and a formula computed from {\sc flask} 
density line of sight integration. The latter is currently used (the others 
are commented out in the script). To generate the {\tt zmin} and {\tt zmax} 
columns in the fields information file, this routine uses the {\tt redshift\_sigma} 
entry in the {\sc camb sources} {\tt .ini} file as half of the redshift bin width. 
Note that {\sc camb sources} assumes, by default, that the redshift bins have Gaussian selection 
functions. If necessary, the user must modify {\sc camb sources} to use 
top-hat redshift bins.

\subsection{{\tt class2info.py}}
\label{sec:class2info}

This {\sc python} script works in the same way as {\tt camb2info.py} but 
for {\sc class} input ({\tt .ini}) files (it uses the {\tt selection\_width} 
keyword as half of the redshift bin width).

\subsection{{\tt ChangeMapResolution.py}}
\label{sec:map-res}

This {\sc python} script gets a {\sc healpix} map in FITS format, changes its 
resolution (given by $N_{\nv{side}}$) and write the new map 
to another FITS file. Its inputs are, in this order: the input map, $N_{\nv{side}}$ 
and the output map. When increasing the resolution, the pixels inside the original 
pixel all get the same value as the original one; and when decreasing the resolution, the new pixel takes 
the average value of the original pixels inside it. 

\subsection{{\tt prepCambInput.py}}
\label{sec:prepcambinput}

This {\sc python} script translates the $C(\ell)$s written by {\sc camb sources} to the 
output file with {\tt scalCovCls.dat} suffix to the $C(\ell)$ files used by {\sc flask} 
as input: besides partitioning the $C(\ell)$s into separate and appropriately named files  
(see Sec. \ref{sec:cls}), it removes the $\ell(\ell+1)/2\pi$ factors to return the pure 
$C(\ell)$s. 

Since {\sc camb sources} output files currently have no headers, this script requires 
as input the fields information file created by {\tt camb2info.py}. Therefore, its input 
parameters are, in this order: the {\sc camb sources} $C(\ell)$s file (with suffix {\tt scalCovCls.dat}); 
the fields information file; and the prefix for the output $C(\ell)$s.

\subsection{{\tt prepClassInput.py}}
\label{sec:prepclassinput}

This {\sc python} script is the analogous of {\tt prepCambInput.py} but for {\sc class} 
output $C(\ell)$s. There are two more differences from {\tt prepCambInput.py}. First, since 
{\sc class} output files have headers, this script does not require a fields information 
file and only take two input parameters, in  this order: the {\sc class} $C(\ell)$s file 
(with {\tt cl.dat} suffix); and the prefix for the output $C(\ell)$s. Second, since 
{\sc class} outputs lensing potential $C(\ell)$s instead of convergence $C(\ell)$s, this script 
converts the former into the latter (and also performs a similar transformation for the cross angular power spectra) using the 
factors described in \citet{Hu00x}. Check the script code for more information. 

\subsection{{\tt summarizeData.py}}
\label{sec:summarizedata}

This {\sc python} script takes a list of $N$ files (which can be specified using wildcards like {\tt *}) 
that must all have the same shape (basically a table with the same number of columns and rows) 
and headers starting with {\tt \#} (or no headers) and compute the average of each entry $x_{ij}$ over all files. 
For example, the table element $\bar{x}_{ij}$ in the output file is given by:

\begin{equation}
\bar{x}_{ij} = \frac{1}{N}\sum_{n=1}^{N}x_{n,ij}.
\label{eq:average}
\end{equation}
This script also computes the standard deviation in an analogous fashion. 
Therefore, the two outputs (the average file and the standard deviation file) have 
the same shape as the input. This script input parameters are, in this order: 
the filename for the average output; the filename for the standard deviation output; 
and the files to be averaged over (which can be specified using wildcards).

\subsection{{\tt ViewMap.py}}
\label{sec:viewmap}

This {\sc python} script takes as arguments filenames of {\sc healpix} maps saved as FITS files 
and plots them in Mollweide projection. Each map is opened in a different window and can be 
saved under different formats.

\subsection{{\tt z-range2camb-ini.py}}
\label{sec:zrange2camb}

This {\sc python} script prints to {\tt stdout} the part of {\sc camb sources} {\tt .ini} file 
that describes the redshift windows for the galaxy counts and lensing. It takes as input a 
redshift range $[z_{\rm{min}}, z_{\rm{max}}]$ and the number of redshift bins $N$, in this order,
and splits the range in contigous $N$ bins that span the range. Currently it only outputs 
counts entries with unit bias and $\frac{\rm{d}}{\rm{d}m}\log_{10}N=0$.   

\subsection{{\tt config-changes.sh}}
\label{sec:config-changes}

This {\sc bash} script prints to {\tt stdout} what changes you must make in your 
configuration file to make it compatible with a certain version of {\sc flask}. 
The idea is that as {\sc flask} is updated, keywords might be added or removed, 
and this scripts helps the user to make previous configuration files compatible 
with new versions of the code by comparing them to the new {\tt example.config} 
file. Check the script comments for more information.   

\subsection{{\tt joinClFiles.py}}
\label{sec:joinClFiles}

This {\sc python} script takes as input an arbitrary number of individual 
power spectra files following {\sc flask}'s naming convention and put them 
into a single file, whose columns will be named {\tt l} (for the multipole numbers 
$\ell$) and the same as the original filenames (for the power spectra columns), 
without the directories and {\tt .dat} extension. It takes as input the individual 
$C^{ij}(\ell)$ files and the output file (that must be the last input passed to this script).

\subsection{{\tt MathMap.py}}
\label{sec:MathMap}

This {\sc python} script allows mathematical operations to be made with {\sc healpix} 
maps with the same $N_{\mathrm{side}}$ directly from the command line. The operations are 
made pixel-wise. It allows for addition, subtraction, multiplication, division and 
exponentiation, as well as parenthesis. For more information, check its docstring by 
running the script without any arguments. An arbitrary number of maps can be operated on, 
and they are referred to by their filenames. It is recommended to always separate all 
terms passed to the script (operators, parenthesis and filenames) by spaces, to avoid 
confusion. Note that parenthesis, multiplication and exponentiation are referred to 
by tailored symbols.


%%%% Bibliografia %%%%
\bibliographystyle{apalike}
\bibliography{main}

\end{document}
